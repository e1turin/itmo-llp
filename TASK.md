# Практические задания к лабораторным работам по дисциплине «Низкоуровневое программирование»

## Задание 1

Создать модуль, реализующий хранение в одном файле данных (выборку, размещение и гранулярное
обновление) информации общим объёмом от 10GB соответствующего варианту вида.
Порядок выполнения:
1. Спроектировать структуры данных для представления информации в оперативной памяти
   - a. Для порции данных, состоящий из элементов определённого рода (см форму данных),
   поддержать тривиальные значения по меньшей мере следующих типов: четырёхбайтовые
   целые числа и числа с плавающей точкой, текстовые строки произвольной длины, булевские
   значения
   - b. Для информации о запросе
2. Спроектировать представление данных с учетом схемы для файла данных и реализовать базовые
   операции для работы с ним:
   - a. Операции над схемой данных (создание и удаление элементов схемы)
   - b. Базовые операции над элементами данных в соответствии с текущим состоянием схемы (над
   узлами или записями заданного вида)
       - i. Вставка элемента данных
       - ii. Перечисление элементов данных
       - iii. Обновление элемента данных
       - iv. Удаление элемента данных
3. Используя в сигнатурах только структуры данных из п.1, реализовать публичный интерфейс со
   следующими операциями над файлом данных:
   - a. Добавление, удаление и получение информации о элементах схемы данных, размещаемых в
   файле данных, на уровне, соответствующем виду узлов или записей
   - b. Добавление нового элемента данных определённого вида
   - c. Выборка набора элементов данных с учётом заданных условий и отношений со смежными
   элементами данных (по свойствам/полями/атрибутам и логическим связям соответственно)
   - d. Обновление элементов данных, соответствующих заданным условиям
   - e. Удаление элементов данных, соответствующих заданным условиям
4. Реализовать тестовую программу для демонстрации работоспособности решения
   - a. Параметры для всех операций задаются посредством формирования соответствующих структур
   данных
   - b. Показать, что при выполнении операций, результат выполнения которых не отражает
   отношения между элементами данных, потребление оперативной памяти стремится к $O(1)$
   независимо от общего объёма фактического затрагиваемых данных
   - c. Показать, что операция вставки выполняется за $O(1)$ независимо от размера данных,
   представленных в файле
   - d. Показать, что операция выборки без учёта отношений (но с опциональными условиями)
   выполняется за $O(n)$, где $n$ – количество представленных элементов данных выбираемого вида
   - e. Показать, что операции обновления и удаления элемента данных выполняются не более чем за
   $O(n*m) > t \to O(n+m)$, где $n$ – количество представленных элементов данных обрабатываемого
   вида, m – количество фактически затронутых элементов данных
   - f. Показать, что размер файла данных всегда пропорционален количеству фактически
   размещённых элементов данных
   - g. Показать работоспособность решения под управлением ОС семейств Windows и *NIX
5. Результаты тестирования по п.4 представить в составе отчёта, при этом:
   - a. В части 3 привести описание структур данных, разработанных в соответствии с п.1
   - b. В части 4 описать решение, реализованное в соответствии с пп.2-3
   - c. В часть 5 включить графики на основе тестов, демонстрирующие амортизированные показатели
   ресурсоёмкости по п. 4

## Вариант 

| Вариант | Форма данных          | Способ работы с файлом | Базовый язык запросов | Формат транспортного протокола | UI API |
|---------|-----------------------|------------------------|-----------------------|--------------------------------|--------|
| 4       | 1. Документное дерево | 2. Отображение         | 4. GraphQL            | 4. Thrift                      | 4      |

## Комментарии

Другие варианты выполнения лабы

- https://gitlab.se.ifmo.ru/omgronny/llp-lab1 — отдельные репозитории, c++.
- https://github.com/deevroman/low-level-programming-labs — версии коммитов, c++.
- https://github.com/Hyperb0rean/itmo_llp3gr — [[--TODO]].
- https://gitlab.se.ifmo.ru/malevrovich/llp-lab1 — отдельные репозитории, с.
- https://github.com/ANegrash/LLP_lab1 — отдельные репозитории, странное.
- https://github.com/vuhtang/nosql-db ― версии коммитов, с.
- https://github.com/ruskaof/llp_database ― еще один интересный пример, c.

Оформление CMakeLists.txt

- https://habr.com/ru/articles/155467/ - Введение в CMake
- https://stackoverflow.com/questions/31969547/what-is-the-difference-between-include-directories-and-target-include-directorie
   - https://stackoverflow.com/questions/40227333/cmake-setup-multiple-projects-and-dependiencies-between-them/40242257#40242257
- https://cmake.org/cmake/help/v3.24/manual/cmake-buildsystem.7.html#transitive-usage-requirements
- крутой пример использования CMake — KDE

Подключение тестов (Google test)

- https://matgomes.com/integrate-google-test-into-cmake/

Настройка сборки в Docker 

- https://www.jetbrains.com/help/clion/clion-toolchains-in-docker.html#build-and-run

Реализация структуры JSON на C++ в Skia

- https://github.com/google/skia/blob/main/src/utils/SkJSON.h

### Заметки по реализации

- будет `node<T>`, отвечающая за элемент дерева: в ней inline хранится значение T (до 32 bit), либо ссылка (61+3 bit) на
  блок значений T большего размера
   - похоже на то, как это реализовано в Skia, но можно не экономить на памяти и сделать тег отдельным полем, кодирующим
     тип с помощью char или даже char[8], чтобы видеть структуру в xxd.
   - не ясно, нужно ли хранить ссылку на родительскую ноду
   - возможно стоит сварить какие-то свои умные указатели, учитывающие офсет в файле
- в блоке значений T находится структура массива char'ов либо `pair<string, T*>`'oв
   - массив пар выглядит более удобным и эффективным, хоть и более затратным по памяти, ведь остаются дырки между концом
     строки и началом T*
- в файле есть корневая `node<Type::Object>`
- в файле для заполнения дырок используется связный список блоков: в каждом блоке хранится ссылка на следующий, либо (в
  зависимости от inline тега) количество последовательных пустых блоков
   - так же можно использовать структуру buddy-аллокатора: массив корневых свободных блоков для разных размеров блоков (
     степени 2) (но сколько тогда?) и дальше так же списком ссылка на следующие
- всё выравнивается по 64bit, т.к. в каждой структуре самое большое это указатель
- в принципе можно обойтись структурой прямо в файле, без отдельных (больших) структур в оперативной памяти